<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DiSMEC++: Model data format</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DiSMEC++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('model-data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Model data format </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Models are saved in multiple files. One file contains metadata, whereas the weights are stored in separate files. We support multiple formats for storing the weights, but the metadata file has always the same structure.</p>
<h1><a class="anchor" id="model-data-meta"></a>
Metadata File</h1>
<p>The metadata is saved as json. It contains the following keys</p><ul>
<li><code>"num-features"</code>: Number of features, i.e. the size of a single weight vector</li>
<li><code>"num-labels"</code>: Number of labels, i.e. the number of weight vectors.</li>
<li><code>"date"</code>: Contains the data and time when the file was created.</li>
<li><code>"weights"</code>: Contains info on where the weights are stored. This is an array of dicts, where each entry corresponds to one weights file. Each weights file stores a contiguous subset (as seen over labels) of the weights. Each entry into the vector has the keys <code>"first"</code>, which is the index of the first label in the file, <code>"count"</code> which is the number of weight vectors, <code>"file"</code> which is the file name relative to the metadata file and <code>"weight-format"</code>, which specifies the format in which the weights are saved.</li>
</ul>
<p>There are several advantages to allowing the weights to be distributed over multiple files. For one, it allows partial saves, e.g. if one wants to do checkpointing. While this could be achieved by simply appending for the human-readable text formats, it may require rewriting the entire file in other settings, e.g. when using compressed files. Secondly, in a distributed setting with a shared, networked file system, we can reduce the amount of data transfer. In distributed training, each worker can save its own weight files, and the main program only needs to be notified that it should update the metadata file. In distributed prediction, each worker only needs to load the weights for the labels it is responsible for, and does not have to parse the entire weight file only to discard most of the weights.</p>
<p>I am planning to add the following additional metadata:</p><ul>
<li>version: To specify which version of the library was used when creating the file</li>
<li>training: A dict which contains information about the training process</li>
<li>custom: Guaranteed to never be written by the library, so save to use for others.</li>
</ul>
<h1><a class="anchor" id="model-data-dense-txt"></a>
Dense Text Format</h1>
<p>Writes all the weights as space-separated numbers. Each line in the file corresponds to a single weight vector. Note that this means that the <em>rows</em> in the text file correspond to the <em>columns</em> in the weight matrix. This is to make it easier to read only a subset of weight vectors from the text file.</p>
<p>Writing is implemented in <a class="el" href="namespacedismec_1_1io_1_1model.html#abfdbf4d49bb96037d6b6df2ce7909191">io::model::save_dense_weights_txt()</a>, and reading in <a class="el" href="namespacedismec_1_1io_1_1model.html#ab23fe02efae025836a76b0ee57ed4b60">io::model::load_dense_weights_txt()</a></p>
<p>The advantage of this format is that it is human readable and very portable. However, it is not efficient both in terms of storage and in terms of read/write performance. This can be influenced to some degree by setting adjusting the precision, i.e. the number of digits written.</p>
<h1><a class="anchor" id="model-data-sparse-txt"></a>
Sparse Text Format</h1>
<p>Writes all the weights exceeding a given threshold in a sparse format. Each row corresponds to one weight vector, and consists of <code>index:value</code> pairs separated by whitespace. Here, index is the 0-based position in the weight vector and value its corresponding value.</p>
<p>This format is human readable and portable, and may be much more space efficient than the dense text format. Storage requirements can be adjusted by setting the precision with which the nonzero weights are written, and by setting the threshold below which weights are culled.</p>
<p>Writing is implemented in <a class="el" href="namespacedismec_1_1io_1_1model.html#a9d15f7ead589f5d5153b1fe92e257aef">io::model::save_as_sparse_weights_txt()</a>, which can also save dense models by culling weights below a specified threshold. Reading is implemented through <a class="el" href="namespacedismec_1_1io_1_1model.html#a09c54fa7d58827f37b2e737624a99e40">io::model::load_sparse_weights_txt()</a>.</p>
<h1><a class="anchor" id="model-data-dense-npy"></a>
Dense Numpy Format</h1>
<p>Writes the weights as a matrix to a <code>.npy</code> file. The data is written in row-major format to allow loading a subset of the labels by reading contiguous parts of the file. Since the output is binary, we operate directly on a stream-buffer here.</p>
<p>This format is more space efficient than the text format, and also has much lower computational overhead, since it does not require any number parsing or formatting. As a rough estimate, for eurlex (~20M weights) saving as (dense) text takes about 8.8 seconds; as npy it takes only about 200 ms. The file size decreases from 230 MB to 80 MB. Similar (though slightly less) speedups appear for loading the model.</p>
<p>Writing is implemented in <a class="el" href="namespacedismec_1_1io_1_1model.html#a4d86304e254fb573e16ec8c846ee3a41">io::model::save_dense_weights_npy()</a> and reading is done using io::model::load_dense_weights_npy. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
